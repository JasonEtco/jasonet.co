---
title: Assorted thoughts on documentation
date: '2020-07-26'
spoiler: Been thinking about documentation a lot recently and wanted to write down what I've seen and learned.
---

Documentation is a fundamental part of software, both open source and proprietary. There are lots of methods for building great docs, and lots of examples of fantastic software with docs that just don't help their users. There have been studies that show that documentation is ["is highly valued, but often overlooked"](https://opensourcesurvey.org/2017/#insights) and my own experience lines up with those findings. So I wanted to share what I know and how I think about documentation, and some recommendations for you (and me).

One note before we get into it: documentation for software is by and large very different from documentation for a product. With the latter, there is a fixed number of actions they can take. Even something as complex and dynamic as [Figma](https://www.figma.com/) has a limit to what a user can do (more on plugin systems and SDKs later on). But when writing docs for software, like a reusable open source library, you need to expect the unexpected - how will consumers of that library use the code? It's not about having that answer, but about giving them the tools to use the code however they want.

## What makes good documentation

This is the big question, and I'm going to separate it into three parts: content, tooling and discoverability. I'll also include some examples, but I'm not an authority on what makes docs good - so I'd love to [hear from you](https://twitter.com/JasonEtco).

### Content

I want to start here, because you can have the most features, the best tooling, all the bells and whistles - but if your content isn't helpful, your docs just aren't going to be good. So what makes content "good"? I think it comes down to focusing on what users **want to accomplish**. Most people don't want to see the entire API surface - they have a goal in mind with your library and want to get there with as little friction and ambiguity as possible.

#### Prioritize use-case-driven examples

This is tricky in practice, because it extends into API design - documenting something complex in nature is going to make for complex documentation. So when you're writing down documentation, try to take the perspective of someone who doesn't know anything about your library, why it exists or how it works - only what it _does_.

For example, let's say we have a library called `math`. It exposes four methods: `add`, `subtract`, `divide`, and `validate`. That last one, `validate`, is used in the first three to validate the arguments passed to each method. We can assume that _most_ users don't need to see that method right away when looking at the docs. They have a problem, like "math is hard" and want to solve that problem, not absorb the complexity of your library.

One library that does this particularly well is 

#### Include reference information

That's not to say that `validate` shouldn't be documented, but it should be less of a priority than use-case-driven examples. You'll see READMEs with a structure like this:

```md
# Name of library

## Installation

## Usage

**Basic example**

**More complex example**

## API reference
```

That's a great place to start from. Start simple, lean on default values of your library, then go more and more complex. Ending with the API details can be really helpful, because you don't know _exactly_ what users want from your library. It _is_ important to share examples of each of those methods though.

I think about [Sequelize's documentation](https://sequelize.org) a lot, specifically their [API reference](https://sequelize.org/v5/identifiers.html). It's an <abbr title="Object-relational mapping">ORM</abbr>, so it is fairly complex and will have a lot to document. Their docs suffer from a really common problem: auto-generated documentation simply isn't helpful enough. They document _everything_, focusing on very little. Here's an example of what I mean ([source](https://sequelize.org/v5/class/lib/query-interface.js~QueryInterface.html#instance-method-dropAllTables)):

<img width="1153" alt="image" src="https://user-images.githubusercontent.com/10660468/88492040-bdc2b980-cf75-11ea-85f1-05e5313e04b5.png">

Because there's no example code here, I have to follow the table of options while making guesses about where and how this method should be used.

There are lots of cases where Sequelize does this really well, outside of the API reference - but when I'm looking at a method's documentation trying to understand what an option does, I need to know what it's for and why I would use it. If you're asking users to read 3 pages, ask yourself if you can condense that or provide links in between.

In contrast, `lodash` [does this really well](https://lodash.com/docs/4.17.15) - each method has what I assume is autogenerated content, paired with real code examples.

I won't pretend that documenting an ORM is as easy as something like `lodash`, but the principles are the same. This gets more and more challenging the larger the API surface, I'll get into that later on.

#### foo/bar/nope

This is a quick win - wherever possible, use real words and real scenarios when showing example code. This comes back to use-case driven content; the typical `foo/bar/baz` wording is ambiguous.

```js
❌ const foo = math.add(1, 2)
   const bar = math.subtract(2, 1)
```

```js
✅ const sum = math.add(1, 2)
   const difference = math.subtract(1, 2)
```

Treat your examples like real code and they'll end up more clear and more helpful.

#### Keep the naming to a minimum

There are micro-ecosystems that have a lot of concepts to wrap your head around. For example, [`unifiedjs`](https://github.com/unifiedjs/unified) - a super powerful and customizable toolchain for manipulating markdown.

I find their documentation really confusing because they reference so many repositories that are built to work within this grouping of plugins. You look at one of those plugins (ex: [`remark-toc`](https://github.com/remarkjs/remark-toc), [`remark-slug`](https://github.com/remarkjs/remark-slug)) and it's really difficult to see how it all comes together. The best resource I found was [an entire tutorial](https://unifiedjs.com/learn/guide/introduction-to-unified/) dedicated to putting those pieces together. 

This isn't meant to point fingers at `unifiedjs` - they have a distributed ecosystem of plugins and pulling everything together is tough. But as a clueless user, finding the best entrypoint is difficult when you have one specific goal. You can help users avoid a rabbit hole of links and jargon by repeating information and bringing context to specific sections of your docs.

### Tooling

Building your own tooling for documentation is silly, and I can say that because I've done it and it was silly. There are plenty of great tools out there, and while none of them are perfect, they are largely good and bad at the same things.

#### Table-stakes features

* Search - users often have an idea of what they want, but either can't verbalize it or can't find it. Search is vital here.
* Localization - even if your project doesn't have the capacity for building all the translations you'd want, the tools you use should still support it. Don't choose a documentation tool that can't expand past one language.
* Syntax highlighted code blocks - every once in a while I come across some docs that miss this. It's surprisingly jarring and confusing.

#### Just write markdown

Most (not all) projects should just have markdown for their documentation. If you're writing HTML and styling your docs, you're adding complexity to what should be a simple toolchain.

There are exceptions - projects that deal heavily in visuals like [TailwindCSS](https://tailwindcss.com/) or [Bootstrap](https://getbootstrap.com/) will need some customized designs. That's fine, but for the projects that are entirely code-for-other-code, markdown is more than enough.

#### Auto-generated documentation

I've never gotten a good result from tools that purport to generate great documentation from your code. I've tried [TypeDoc](https://github.com/TypeStrong/typedoc/), [JSDoc](https://jsdoc.app/), [Godoc](https://godoc.org/), written my own nonsense, and probably some other ones I'm forgetting. Thhe value in those tools is that they make it easier to document the API - but they don't help to write _good_ docs. Simply documenting your whole API is _not_ going to be helpful for your users. That doesn't mean these tools aren't useful, but they aren't enough on their own, and I've struggled getting them to work together with other tooling.

### Discoverability

#### Reduce context switching

#### More on localization

I am far from an expert here, but I'll share what I've learned.

[Crowdin](https://crowdin.com/) is a great tool for letting contributors write translations. Their pricing page includes a callout for open source projects. You do [have to request approval](https://crowdin.com/page/open-source-project-setup-request).

Crowdin integrates with GitHub, so if your docs are markdown files in your repository, that's a great start.

#### Jason's favorite tools

Firstly, I think that "documentation tooling" is one of the development world's biggest mistakes. It simply shouldn't be necessary to "build" your docs, or spend hours setting up the perfect docs site. [GitBook](https://www.gitbook.com/)'s GitHub integration is the closest I've seen to a workflow that is "toolless" and still pretty good. That said, here are some of the tools I've tried and liked:

* [Vuepress](https://vuepress.vuejs.org/) makes for a pretty site. It has features like search and localization built-in. It takes some work to configure the way you want it though.
* [Docusaurus](https://docusaurus.io/) is pretty similar, it calls out Crowdin in its docs.

### Bonus: contribution workflow

## Docs for a product's SDK or API

This is a bit of a gray area - earlier I noted that documenting a product is different from software, but there are platforms that have to do a bit of both. Take GitHub for example - it has a robust API that intersects with many of the same product areas as the UI on GitHub.com.